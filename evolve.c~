/*---------------------------------------------------------
codigo que evoluciona un archivo con condiciones iniciales
-----------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

const float G=4.47  *pow(10,-24); //Constante gravitacional en Kpc3/(mSolares * year2)
const float m=pow(10,12); //Masa solar
const float h=10000;//year


float func_prime_1(float x,float y_1,float x_1,float y_2,float *x_m,float *y_m,int *id,int a);
float func_prime_2(float x,float y_1,float x_1,float y_2,float *x_m ,float *y_m,int *id, int a);
float *RungeKutta(float x_old, float y1_old,float x_1, float y2_old,float *x_m,float *y_m,int *id,int a);



//Main
int main(int argc, char **argv){
  int var, num_lineas;
  FILE *input;
  var=0;
  input = fopen(argv[1], "r");
/*---------------------------------------------------------
toma como archivo base el primer argumento y cuenta sus lineas
-----------------------------------------------------------*/
    num_lineas=0;
    while ((var = fgetc(input)) != EOF){
      if (var =='\n')
	++num_lineas;
    }

    printf("NÃºmero de lineas del archivo:\n -->%d\n",num_lineas); 

/*---------------------------------------------------------
llama el archivo producido, convierte y coloca en distintos arrays cada columna
convierte a km y a km/Myrs
-----------------------------------------------------------*/  	
    float *xo;
    float *yo;
    float *V_xo;
    float *V_yo;
    int *ID;

    ID=malloc(num_lineas*sizeof(int));
    xo= malloc(num_lineas*sizeof(float));
    yo= malloc(num_lineas*sizeof(float));
    V_xo= malloc(num_lineas*sizeof(float));
    V_yo= malloc(num_lineas*sizeof(float));

    
    /*---------------------------------------------------------
Registro de Datos en los arrays
-----------------------------------------------------------*/
    float b,c,d,e;
    int j,a;
    for(j=0;j<num_lineas;j++){
      fscanf(input, "%d %f %f %f %f",&a,&b,&c,&d,&e);//en kpc, km/s
      ID[j]=a;
      xo[j]=b;
      yo[j]=c;
      V_xo[j]=d*(3.1536*pow(10,7));
      V_yo[j]=e*(3.1536*pow(10,7));


      if(!ID[j]|| !xo[j]||!yo[j]||!V_xo[j]||!V_yo[j]){
	printf("Existe una linea vacia o hay un problema con la linea %d en el archivo\n",j);
	exit(1);
     } 
    }
    
/*---------------------------------------------------------
Usando RUNGEKUTTA:
se aplica a cada particula alrededor de la particula central el cambio de posicion y 
velocidades dado por la interaccion con cada particula central presente por cada cambio de tiempo 
-----------------------------------------------------------*/  
    float *data;
    data=malloc(num_lineas*sizeof(float));
    float time;
    int part,centros;
    j=0;
    //Conteo de todas las particulas centrales

    centros=0;
    float dt=1;

    for (j=0;j<num_lineas;j++){
      if( ID[j]==-1){
	centros++;
      }
    }

    /*-----------------------------------------------------------------------------------------

    Crea una lista de la ubicacion y velocidades de los nuevos centros de masa
      --------------------------------------------------------------------------------------*/
    int *CID;
    float *Cx;
    float *Cy;
    float *CVx;
    float *CVy;
    int i=0;

    CID=malloc(centros*sizeof(int));
    Cx=malloc(centros*sizeof(float));
    Cy=malloc(centros*sizeof(float));
    CVx=malloc(centros*sizeof(float));
    CVy=malloc(centros*sizeof(float));

    for (j=0;j<num_lineas;j++){
      if( ID[j]==-1){
	CID[i]=i;
	Cx[i]=xo[j];
	Cy[i]=yo[j];
	CVx[i]=V_xo[j];
	CVy[i]=V_yo[j];
	i++;
      }
    }

    /*-----------------------------------------------------------------------------------------

      --------------------------------------------------------------------------------------*/

    float maximo=5000.0;

    FILE *output1;
    char filename1[100]="evolve_output1.dat";
    output1=fopen(filename1,"w");

    FILE *output2;
    char filename2[100]="evolve_output2.dat";
    output2=fopen(filename2,"w");

    FILE *output3;
    char filename3[100]="evolve_output3.dat";
    output3=fopen(filename3,"w");

    FILE *output4;
    char filename4[100]="evolve_output4.dat";
    output4=fopen(filename4,"w");

    FILE *output5;
    char filename5[100]="evolve_output5.dat";
    output5=fopen(filename5,"w");

   


    for(time=0;time<maximo;time++){
      for(part=0;part<num_lineas;part++){
	if (time==1000) {
	 fprintf(output1,"-1 %f %f %f %f\n",xo[part],yo[part],V_xo[part]/(3.1536*pow(10,7)),V_yo[part]/(3.1536*pow(10,7)));
	  }
	if (time==2000) {
	 fprintf(output2,"-1 %f %f %f %f\n",xo[part],yo[part],V_xo[part]/(3.1536*pow(10,7)),V_yo[part]/(3.1536*pow(10,7)));
	  }
	if (time==3000) {
	 fprintf(output3,"-1 %f %f %f %f\n",xo[part],yo[part],V_xo[part]/(3.1536*pow(10,7)),V_yo[part]/(3.1536*pow(10,7)));
	  }
	if (time==4000) {
	 fprintf(output4,"-1 %f %f %f %f\n",xo[part]/(3.0*pow(10.0,16.0)),yo[part]/(3.0*pow(10.0,16.0)),V_xo[part]/(3.1536*pow(10,13)),V_yo[part]/(3.1536*pow(10,13)));
	  }
	if (time==4999) {
	 fprintf(output5,"-1 %f %f %f %f\n",xo[part],yo[part],V_xo[part]/(3.1536*pow(10,7)),V_yo[part]/(3.1536*pow(10,7)));
	  }
	if(ID[j]==-1)
	  {
	    if(centros==1){
	      xo[j]+=V_xo[j]*dt;
	      yo[j]+=V_yo[j]*dt;
	    }  
	    else{

	      data=RungeKutta(time,xo[part],yo[part],V_xo[part],Cx,Cy,ID,1);
	      xo[part]=data[1];
	      V_xo[part]=data[2];
	      data=RungeKutta(time,yo[part],xo[part],V_yo[part],Cy,Cx,ID,1);
	      yo[part]=data[1];
	      V_yo[part]=data[2];
	    }
	  }
      
 
	else //(ID[j]>-1)
	  {
	    data=RungeKutta(time,xo[part],yo[part],V_xo[part],Cx,Cy,ID,0);
	    xo[part]=data[1];
	    V_xo[part]=data[2];
	    data=RungeKutta(time,yo[part],xo[part],V_yo[part],Cy,Cx,ID,0);
	    yo[part]=data[1];
	    V_yo[part]=data[2];	    
	  }
      }
    }

    
    
    	

/*---------------------------------------------------------
exporta los datos de posicion y velocidades por cada particula en varios archivos que representan una ubicacion en el tiempo
-----------------------------------------------------------*/  

/*---------------------------------------------------------
FIN
-----------------------------------------------------------*/   
  return 0;
}














float func_prime_1(float x,float y_1,float x_1,float y_2,float *x_m,float *y_m,int *id,int a){
  return y_2;
}

float func_prime_2(float x,float y_1,float x_1,float y_2,float *x_m ,float *y_m,int *id, int a){
  float chapa1,chapa2;
  int ajiaco=sizeof(x_m);
  if (a != 1){
    
    float deltax,deltay;
    int i;
    
    for(i=0;i<ajiaco;i++){

    deltax=x_m[i]-y_1;
    deltay=y_m[i]-x_1;
    chapa1=pow(deltax,2)+pow(deltay,2);
    chapa2=-(G*m/pow(chapa1,(3/2)))*deltax;
    }
  }
  else{
    int i;

    for(i=0;i<ajiaco;i++){
      if(i==id[i]){
	continue;
      }
      float deltax=x_m[i]-y_1;
      float deltay=y_m[i]-x_1;
      chapa1=pow(deltax,2)+pow(deltay,2);
      chapa2=-(G*m/pow(chapa1,(3/2)))*deltax;
      }
  }
  return chapa2;
}

float *RungeKutta(float x_old, float y1_old,float x_1, float y2_old,float *x_m,float *y_m,int *id,int a){
  float k1= func_prime_1(x_old,y1_old,x_1,y2_old, x_m,y_m,id,a);
  float k11= func_prime_2(x_old,y1_old,x_1,y2_old, x_m, y_m,id,a);
  //Primer paso
  
  float x1=x_old + (h/2.0);
  float y1=y1_old + (h/2.0)*k1;
  float y11=y2_old + (h/2.0)*k11;

  float k2= func_prime_1(x1,y1,x_1,y11,x_m, y_m,id,a);
  float k21= func_prime_2(x1,y1,x_1,y11,x_m, y_m,id,a);

  //segundo paso
  
  float x2=x_old + (h/2.0);
  float y2=y1_old + (h/2.0)*k2;
  float y21=y2_old + (h/2.0)*k2;

  float k3= func_prime_1(x2,y2,x_1,y21,x_m, y_m,id,a);
  float k31= func_prime_2(x2,y2,x_1,y21,x_m, y_m,id,a);


  //tercer paso
  
  float x3=x_old + (h);
  float y3=y1_old + (h)*k3;
  float y31=y2_old + (h)*k31;

  float k4= func_prime_1(x3,y3,x_1,y31,x_m, y_m,id,a);
  float k41= func_prime_2(x3,y3,x_1,y31, x_m, y_m,id,a);

  //cuarto paso
  float prom_k1=(1.0/6.0)*(k1 + 2.0*k2+ 2.0*k3 + k4);
  float prom_k2=(1.0/6.0)*(k11 + 2.0*k21+ 2.0*k31 + k41);
  



  //entrega de datos
  float x_new =x_old + h;
  float y1_new=y1_old + h*prom_k1;
  float y2_new=y2_old + h*prom_k2;
  float *mojo = malloc(3*sizeof(float));
  mojo[0]=x_new;
  mojo[1]=y1_new;
  mojo[2]=y2_new;
  return mojo;

}
